# NArray
This project was created as a vehicle for exploring how various aspects of the C++ programming language could be used to create framework code. Framework code is code intended to be used by other coders, such as the classes and functions in a maths library. The example chosen was that of multi-dimensional arrays, but over time the project grew to include multi-threading, socket communication and graphics handling. Above all, the project was a learning experience, but it reached sufficient maturity that I am now sharing it as a means of demonstrating my understanding of the C++ programming language to prospective employers.

A key aspect of the C++ programming language the project relies on is its support for generic programming (sometimes referred to as compile-time polymorphism) through the use of templates. We want users of the code to be able to create multi-dimensional arrays without restricting what they store in those arrays. The classes are templated (sometimes referred to as parameterised) on the types they will be expanded with at compile time. For this reason, the classes are defined in header files that clients include in their source files and where they specify the data type they actually want to store. This could be a built-in primitive such as an int, something from the STL such as a string, or a class of their own creation.

Generic programming techniques are also used to capture the concept of multi-dimensionality by employing a recursive template structure. The recursion starts with the zeroth dimension (a scalar) which is implemented by the NArrayAxiomatic class, templated on what the user wants to store in the array. All additional dimensions (first dimension is a vector, second dimension is a matrix etc) are implemented by the NArrayRecursive class, templated on what will be stored at the next level down. As an example, a two dimensional array of doubles (a matrix) is implemented as the NArrayRecursive class templated on a one dimensional array of doubles (a vector), which is in turn implemented as the NArrayRecursive class templated on a zero dimensional array of doubles (a scalar), which is in turn implemented as the NArrayAxiomatic class templated on a double. A templated struct of typedefs, called NArrayType, has been created for the first twenty dimensions to simplify the construction of these nested templates. This can easily be extended if higher dimensions are required. Although this recursive template structure greatly reduces the amount of code needed to represent arrays of arbitrary dimensionality (just two templated classes, NArrayAxiomatic and NArrayRecursive) it does mean that the dimensionality of an array cannot be specified at runtime, it has to be known at compile time. During compilation, the code will expand to meet the desired dimensionality, something to be wary of if template-induced code bloat is likely to be a problem, such as in embedded code.

Another key aspect of the C++ programming language the project relies on is its support for run-time polymorphism through the use of virtual functions, in particular, pure virtual functions. We want users of the code to be able to create functions that operate on the data in their multi-dimensional arrays, but we cannot know up-front how those functions will be implemented. To this end, the abstract classes SingleThreadedOperator, SingleThreadedTransform, MultiThreadedOperator and MultiThreadedTransform were created. It is intended that the user will create concrete classes that are derived from these abstract classes in order to meet their data processing needs. Functionality to use such classes has been built into the recursive template structure in the form of the ApplySingleThreadedOperator, ApplySingleThreadedTransform, ApplyMultiThreadedOperator and ApplyMultiThreadedTransform functions in the NArrayAxiomatic and NArrayRecursive classes. The difference between an operator and a transform is that an operator outputs data of the same data type as its input data type, whereas a transform can output data of a different data type to its input data type. The difference between single-threaded and multi-threaded is that in multi-threading a new thread is spawned to perform the user-defined functionality of the operator or transform whereas in single-threading this functionality is carried out in the main thread. It is down to the user to determine if their operator or transform is safe to use in a multi-threaded case and to introduce mutexes where thread contention may be a problem in the multi-threaded case.
